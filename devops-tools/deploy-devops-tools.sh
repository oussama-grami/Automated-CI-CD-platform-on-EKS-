#!/bin/bash

# =============================================================================
# SCRIPT DE D√âPLOIEMENT DES OUTILS DEVOPS SUR EKS
# Fichier: deploy-devops-tools.sh
# =============================================================================

set -e

# Configuration des couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Fonctions de logging
log_info() {
    echo -e "${BLUE}[$(date '+%H:%M:%S')] [INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[$(date '+%H:%M:%S')] [SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[$(date '+%H:%M:%S')] [WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[$(date '+%H:%M:%S')] [ERROR]${NC} $1"
}

log_step() {
    echo ""
    echo -e "${BOLD}${PURPLE}=============================================="
    echo -e "    $1"
    echo -e "===============================================${NC}"
    echo ""
}

show_banner() {
    echo ""
    echo -e "${BOLD}${CYAN}================================================"
    echo -e "    üöÄ D√âPLOIEMENT OUTILS DEVOPS SUR EKS"
    echo -e "    üì¶ Nexus ‚Ä¢ SonarQube ‚Ä¢ ArgoCD ‚Ä¢ GitLab Runner"
    echo -e "================================================${NC}"
    echo ""
}

# V√©rification des pr√©requis
check_prerequisites() {
    log_step "üîç V√âRIFICATION DES PR√âREQUIS"
    
    local tools=("kubectl" "aws" "tofu" "helm")
    for tool in "${tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            log_error "$tool non trouv√©. Veuillez l'installer d'abord."
            exit 1
        fi
        log_success "‚úì $tool disponible"
    done
    
    # V√©rifier l'acc√®s au cluster
    if ! kubectl cluster-info &> /dev/null; then
        log_error "Impossible d'acc√©der au cluster Kubernetes"
        log_info "Assurez-vous que votre kubeconfig est configur√© correctement"
        exit 1
    fi
    log_success "‚úì Acc√®s au cluster confirm√©"
    
    # V√©rifier les credentials AWS
    if ! aws sts get-caller-identity &> /dev/null; then
        log_error "Credentials AWS non configur√©s"
        exit 1
    fi
    log_success "‚úì Credentials AWS configur√©s"
    
    # V√©rifier les fichiers requis
    local required_files=("devops-tools.tf" "devops-vars.tfvars")
    for file in "${required_files[@]}"; do
        if [ ! -f "$file" ]; then
            log_error "Fichier $file non trouv√©"
            exit 1
        fi
        log_success "‚úì Fichier $file trouv√©"
    done
    
    # V√©rifier que le cluster EKS existe
    CLUSTER_NAME=$(grep "^cluster_name" devops-vars.tfvars | head -1 | cut -d'"' -f2)
    AWS_REGION=$(grep "^aws_region" devops-vars.tfvars | head -1 | cut -d'"' -f2)
    
    if ! aws eks describe-cluster --name "$CLUSTER_NAME" --region "$AWS_REGION" &>/dev/null; then
        log_error "Cluster EKS '$CLUSTER_NAME' non trouv√© dans la r√©gion '$AWS_REGION'"
        log_info "Cr√©ez d'abord le cluster avec ./deploy-cluster.sh"
        exit 1
    fi
    log_success "‚úì Cluster EKS '$CLUSTER_NAME' trouv√©"
    
    log_success "Tous les pr√©requis sont satisfaits"
}

# Configurer Helm repositories
setup_helm_repos() {
    log_step "üì¶ CONFIGURATION DES REPOSITORIES HELM"
    
    log_info "Ajout des repositories Helm..."
    
    # Ajouter les repos n√©cessaires
    helm repo add aws-ebs-csi-driver https://kubernetes-sigs.github.io/aws-ebs-csi-driver &>/dev/null || true
    helm repo add sonarqube https://SonarSource.github.io/helm-chart-sonarqube &>/dev/null || true
    helm repo add argo https://argoproj.github.io/argo-helm &>/dev/null || true
    
    log_info "Mise √† jour des repositories..."
    helm repo update &>/dev/null
    
    log_success "‚úì Repositories Helm configur√©s"
}

# Nettoyer les ressources existantes si n√©cessaire
cleanup_existing_resources() {
    log_step "üßπ NETTOYAGE DES RESSOURCES EXISTANTES"
    
    log_info "V√©rification des ressources existantes..."
    
    # Supprimer les anciens namespaces de test
    kubectl delete namespace ebs-test --ignore-not-found=true &>/dev/null || true
    kubectl delete namespace volume-test --ignore-not-found=true &>/dev/null || true
    kubectl delete namespace test --ignore-not-found=true &>/dev/null || true
    
    # Nettoyer les PVCs bloqu√©s
    log_info "Nettoyage des PVCs en √©tat Pending/Failed..."
    kubectl get pvc --all-namespaces 2>/dev/null | grep -E "(Pending|Failed)" | while read namespace pvc rest; do
        if [ "$namespace" != "NAMESPACE" ] && [ -n "$namespace" ] && [ -n "$pvc" ]; then
            log_info "Suppression PVC bloqu√©: $pvc dans $namespace"
            kubectl delete pvc "$pvc" -n "$namespace" --force --grace-period=0 &>/dev/null || true
        fi
    done
    
    log_success "‚úì Nettoyage termin√©"
}

# Initialiser Terraform
init_terraform() {
    log_step "üîß INITIALISATION TERRAFORM"
    
    log_info "Initialisation d'OpenTofu..."
    tofu init
    
    log_info "Validation de la configuration..."
    tofu validate
    
    log_success "‚úì OpenTofu initialis√© et configuration valid√©e"
}

# Planifier le d√©ploiement
plan_deployment() {
    log_step "üìã PLANIFICATION DU D√âPLOIEMENT"
    
    log_info "G√©n√©ration du plan de d√©ploiement..."
    tofu plan -var-file="devops-vars.tfvars" -out=devops-plan.out
    
    log_success "‚úì Plan de d√©ploiement g√©n√©r√©"
}

# Appliquer le d√©ploiement
apply_deployment() {
    log_step "üöÄ D√âPLOIEMENT DES OUTILS DEVOPS"
    
    log_info "Application du plan de d√©ploiement..."
    log_warning "Ceci peut prendre 10-15 minutes..."
    
    tofu apply devops-plan.out
    
    log_success "‚úì D√©ploiement appliqu√© avec succ√®s"
}

# Attendre que tous les pods soient pr√™ts
wait_for_pods() {
    log_step "‚è≥ ATTENTE DE LA PR√âPARATION DES SERVICES"
    
    local namespaces=("kube-system" "nexus" "sonarqube" "argocd" "devops")
    
    for namespace in "${namespaces[@]}"; do
        log_info "V√©rification des pods dans le namespace $namespace..."
        
        # Attendre que tous les pods soient en cours d'ex√©cution
        local max_attempts=20
        local attempt=1
        
        while [ $attempt -le $max_attempts ]; do
            local pending_pods=$(kubectl get pods -n "$namespace" 2>/dev/null | grep -E "(Pending|ContainerCreating|Init)" | wc -l || echo "0")
            
            if [ "$pending_pods" -eq 0 ]; then
                log_success "‚úì Tous les pods sont pr√™ts dans $namespace"
                break
            fi
            
            log_info "Tentative $attempt/$max_attempts - $pending_pods pod(s) encore en cours de cr√©ation dans $namespace..."
            sleep 30
            ((attempt++))
        done
        
        if [ $attempt -gt $max_attempts ]; then
            log_warning "Certains pods dans $namespace prennent plus de temps que pr√©vu"
        fi
    done
    
    # V√©rification sp√©cifique pour les services critiques
    log_info "V√©rification de la sant√© des services critiques..."
    
    # Attendre EBS CSI Driver
    kubectl wait --for=condition=ready pod -l app=ebs-csi-controller -n kube-system --timeout=300s || log_warning "EBS CSI Controller timeout"
    kubectl wait --for=condition=ready pod -l app=ebs-csi-node -n kube-system --timeout=300s || log_warning "EBS CSI Node timeout"
    
    # Attendre Nexus
    kubectl wait --for=condition=ready pod -l app=nexus -n nexus --timeout=600s || log_warning "Nexus timeout"
    
    # Attendre SonarQube
    kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=sonarqube -n sonarqube --timeout=600s || log_warning "SonarQube timeout"
    
    # Attendre ArgoCD
    kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s || log_warning "ArgoCD timeout"
    
    log_success "‚úì Services critiques v√©rifi√©s"
}

# Tester la connectivit√© des services
test_services() {
    log_step "üß™ TEST DE CONNECTIVIT√â DES SERVICES"
    
    log_info "Test de cr√©ation d'un volume persistant..."
    
    # Cr√©er un namespace de test
    kubectl create namespace volume-test --dry-run=client -o yaml | kubectl apply -f - &>/dev/null
    
    # Cr√©er un PVC de test
    cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-pvc
  namespace: volume-test
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: gp3
EOF

    # Attendre que le PVC soit Bound (mais ne pas √©chouer si timeout)
    if kubectl wait --for=condition=Bound pvc/test-pvc -n volume-test --timeout=120s; then
        log_success "‚úì Test de volume persistant r√©ussi"
    else
        log_warning "‚ö† Test de volume avec timeout, mais v√©rifions le statut..."
        
        # V√©rifier le statut du PVC malgr√© le timeout
        PVC_STATUS=$(kubectl get pvc test-pvc -n volume-test -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
        if [ "$PVC_STATUS" = "Bound" ]; then
            log_success "‚úì Volume persistant est en fait Bound - test r√©ussi !"
        else
            log_warning "‚ö† Volume persistant en statut: $PVC_STATUS"
            kubectl describe pvc test-pvc -n volume-test || true
        fi
    fi
    
    # Nettoyer le test
    kubectl delete namespace volume-test &>/dev/null || true
    
    # Tester la disponibilit√© des services
    log_info "V√©rification de la disponibilit√© des services..."
    
    local services=(
        "nexus-service:nexus:8081"
        "sonarqube-sonarqube:sonarqube:9000"
        "argocd-server:argocd:80"
    )
    
    for service_info in "${services[@]}"; do
        IFS=':' read -r service namespace port <<< "$service_info"
        if kubectl get svc "$service" -n "$namespace" &>/dev/null; then
            log_success "‚úì Service $service disponible dans $namespace"
        else
            log_warning "‚ö† Service $service non trouv√© dans $namespace"
        fi
    done
    
    log_success "‚úì Tests de connectivit√© termin√©s"
    
    # IMPORTANT: Ne jamais retourner d'erreur ici pour √©viter le cleanup
    return 0
}

# Afficher les informations de d√©ploiement
display_deployment_info() {
    log_step "üìä INFORMATIONS DE D√âPLOIEMENT"
    
    # R√©cup√©rer les informations via Terraform output
    local deployment_info
    deployment_info=$(tofu output -json deployment_info 2>/dev/null || echo '{}')
    
    echo -e "${BOLD}${GREEN}üéâ D√âPLOIEMENT TERMIN√â AVEC SUCC√àS ! üéâ${NC}"
    echo ""
    
    echo -e "${BOLD}${BLUE}üìã SERVICES D√âPLOY√âS:${NC}"
    echo -e "${GREEN}   ‚úì EBS CSI Driver (Stockage persistant)${NC}"
    echo -e "${GREEN}   ‚úì Nexus Repository Manager${NC}"
    echo -e "${GREEN}   ‚úì SonarQube (Analyse de code)${NC}"
    echo -e "${GREEN}   ‚úì ArgoCD (D√©ploiement continu)${NC}"
    echo -e "${GREEN}   ‚úì GitLab Runner (CI/CD)${NC}"
    echo ""
    
    echo -e "${BOLD}${CYAN}üåê ACC√àS AUX SERVICES:${NC}"
    echo ""
    echo -e "${YELLOW}Nexus Repository Manager:${NC}"
    echo "   URL: http://localhost:8081"
    echo "   Commande: kubectl port-forward svc/nexus-service 8081:8081 -n nexus"
    echo "   Identifiants: admin / $(grep nexus_admin_password devops-vars.tfvars | cut -d'"' -f2)"
    echo ""
    
    echo -e "${YELLOW}SonarQube:${NC}"
    echo "   URL: http://localhost:9000"
    echo "   Commande: kubectl port-forward svc/sonarqube-sonarqube 9000:9000 -n sonarqube"
    echo "   Identifiants: admin / $(grep sonarqube_admin_password devops-vars.tfvars | cut -d'"' -f2)"
    echo ""
    
    echo -e "${YELLOW}ArgoCD:${NC}"
    echo "   URL: http://localhost:8080"
    echo "   Commande: kubectl port-forward svc/argocd-server 8080:80 -n argocd"
    echo "   Identifiants: admin / $(grep argocd_admin_password devops-vars.tfvars | cut -d'"' -f2)"
    echo ""
    
    echo -e "${BOLD}${PURPLE}üîß COMMANDES UTILES:${NC}"
    echo "   ‚Ä¢ Voir tous les pods: kubectl get pods --all-namespaces"
    echo "   ‚Ä¢ Voir les services: kubectl get svc --all-namespaces"
    echo "   ‚Ä¢ Voir les PVCs: kubectl get pvc --all-namespaces"
    echo "   ‚Ä¢ Logs Nexus: kubectl logs -l app=nexus -n nexus"
    echo "   ‚Ä¢ Logs SonarQube: kubectl logs -l app.kubernetes.io/name=sonarqube -n sonarqube"
    echo "   ‚Ä¢ Logs ArgoCD: kubectl logs -l app.kubernetes.io/name=argocd-server -n argocd"
    echo ""
    
    echo -e "${BOLD}${GREEN}üéØ PROCHAINES √âTAPES:${NC}"
    echo "   1. Cr√©er des LoadBalancers pour l'acc√®s externe: ./create-loadbalancers.sh"
    echo "   2. Configurer vos projets GitLab avec le runner d√©ploy√©"
    echo "   3. Configurer ArgoCD avec vos repositories Git"
    echo ""
    
    # Sauvegarder les informations
    cat > deployment-info.txt << EOF
=== INFORMATIONS DE D√âPLOIEMENT DEVOPS ===
Date de d√©ploiement: $(date)
Cluster: $(grep cluster_name devops-vars.tfvars | cut -d'"' -f2)
R√©gion: $(grep aws_region devops-vars.tfvars | cut -d'"' -f2)

ACC√àS AUX SERVICES:
===================

Nexus Repository Manager:
- URL locale: http://localhost:8081
- Port-forward: kubectl port-forward svc/nexus-service 8081:8081 -n nexus
- Username: admin
- Password: $(grep nexus_admin_password devops-vars.tfvars | cut -d'"' -f2)

SonarQube:
- URL locale: http://localhost:9000
- Port-forward: kubectl port-forward svc/sonarqube-sonarqube 9000:9000 -n sonarqube
- Username: admin
- Password: $(grep sonarqube_admin_password devops-vars.tfvars | cut -d'"' -f2)

ArgoCD:
- URL locale: http://localhost:8080
- Port-forward: kubectl port-forward svc/argocd-server 8080:80 -n argocd
- Username: admin
- Password: $(grep argocd_admin_password devops-vars.tfvars | cut -d'"' -f2)

COMMANDES UTILES:
================
kubectl get pods --all-namespaces
kubectl get svc --all-namespaces
kubectl get pvc --all-namespaces

PROCHAINES √âTAPES:
==================
1. ./create-loadbalancers.sh (pour l'acc√®s externe)
2. Configurer GitLab avec le runner
3. Configurer ArgoCD avec vos repositories
EOF
    
    log_success "Informations sauvegard√©es dans 'deployment-info.txt'"
}

# Fonction de nettoyage en cas d'erreur
cleanup_on_failure() {
    log_error "Erreur d√©tect√©e pendant le d√©ploiement"
    log_warning "Voulez-vous nettoyer les ressources partiellement cr√©√©es ? (y/N)"
    
    read -p "Nettoyer ? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_warning "Nettoyage en cours..."
        
        # Supprimer les ressources Terraform si elles existent
        if [ -f "devops-plan.out" ]; then
            tofu destroy -var-file="devops-vars.tfvars" -auto-approve &>/dev/null || true
        fi
        
        # Nettoyer les fichiers temporaires
        rm -f devops-plan.out &>/dev/null || true
        
        log_info "Nettoyage termin√©"
    else
        log_info "Nettoyage annul√© - les ressources sont conserv√©es"
        log_info "Vous pouvez les v√©rifier avec: kubectl get pods --all-namespaces"
    fi
}

# Fonction pour afficher l'aide
show_help() {
    echo -e "${BOLD}${BLUE}Usage: $0 [OPTION]${NC}"
    echo ""
    echo "Options:"
    echo "  (aucune)  D√©ploiement complet des outils DevOps"
    echo "  destroy   Suppression compl√®te de tous les outils"
    echo "  status    Affichage du statut des services"
    echo "  help      Affichage de cette aide"
    echo ""
    echo "Exemples:"
    echo "  $0           # D√©ploiement complet"
    echo "  $0 status    # V√©rifier le statut"
    echo "  $0 destroy   # Supprimer tous les outils"
    echo ""
}

# Fonction pour v√©rifier le statut
check_status() {
    log_step "üìä STATUT DES SERVICES DEVOPS"
    
    echo -e "${BOLD}${BLUE}√âtat des namespaces:${NC}"
    kubectl get ns | grep -E "(nexus|sonarqube|argocd|devops)" || echo "Aucun namespace DevOps trouv√©"
    
    echo ""
    echo -e "${BOLD}${BLUE}√âtat des pods:${NC}"
    kubectl get pods -n nexus -o wide 2>/dev/null || echo "Namespace nexus non trouv√©"
    kubectl get pods -n sonarqube -o wide 2>/dev/null || echo "Namespace sonarqube non trouv√©"
    kubectl get pods -n argocd -o wide 2>/dev/null || echo "Namespace argocd non trouv√©"
    kubectl get pods -n devops -o wide 2>/dev/null || echo "Namespace devops non trouv√©"
    
    echo ""
    echo -e "${BOLD}${BLUE}√âtat des services:${NC}"
    kubectl get svc -n nexus 2>/dev/null || echo "Aucun service nexus"
    kubectl get svc -n sonarqube 2>/dev/null || echo "Aucun service sonarqube"
    kubectl get svc -n argocd 2>/dev/null || echo "Aucun service argocd"
    
    echo ""
    echo -e "${BOLD}${BLUE}√âtat des PVCs:${NC}"
    kubectl get pvc --all-namespaces | grep -E "(nexus|sonarqube)" || echo "Aucun PVC trouv√©"
    
    echo ""
    echo -e "${BOLD}${BLUE}EBS CSI Driver:${NC}"
    kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-ebs-csi-driver || echo "EBS CSI Driver non trouv√©"
}

# Fonction pour d√©truire le d√©ploiement
destroy_deployment() {
    log_step "üí• DESTRUCTION DES OUTILS DEVOPS"
    
    log_warning "ATTENTION: Cette action va supprimer tous les outils DevOps !"
    log_warning "Toutes les donn√©es seront perdues d√©finitivement !"
    echo ""
    read -p "√ätes-vous s√ªr de vouloir continuer? Tapez 'DESTROY' pour confirmer: " -r
    echo
    
    if [[ $REPLY != "DESTROY" ]]; then
        log_info "Destruction annul√©e"
        exit 0
    fi
    
    log_info "Destruction en cours..."
    
    # Utiliser Terraform pour d√©truire proprement
    if [ -f "devops-tools.tf" ]; then
        tofu destroy -var-file="devops-vars.tfvars" -auto-approve
    fi
    
    # Nettoyer manuellement si n√©cessaire
    log_info "Nettoyage des ressources restantes..."
    kubectl delete namespace nexus sonarqube argocd devops --ignore-not-found=true &>/dev/null || true
    
    # Supprimer les fichiers temporaires
    rm -f devops-plan.out deployment-info.txt &>/dev/null || true
    
    log_success "‚úì Destruction termin√©e"
}

# Fonction principale
main() {
    show_banner
    
    # V√©rifier les pr√©requis
    check_prerequisites
    
    # Demander confirmation
    echo ""
    read -p "Voulez-vous d√©ployer les outils DevOps sur le cluster EKS? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "D√©ploiement annul√© par l'utilisateur"
        exit 0
    fi
    
    # Pi√®ge pour nettoyer en cas d'erreur
    trap cleanup_on_failure ERR
    
    # √âtapes du d√©ploiement
    setup_helm_repos
    cleanup_existing_resources
    init_terraform
    plan_deployment
    apply_deployment
    wait_for_pods
    test_services
    display_deployment_info
    
    # Nettoyer les fichiers temporaires de plan
    rm -f devops-plan.out &>/dev/null || true
    
    echo ""
    log_success "üéâ D√âPLOIEMENT DEVOPS TERMIN√â AVEC SUCC√àS ! üéâ"
    echo ""
    echo "Tous vos outils DevOps sont maintenant op√©rationnels !"
    echo "Utilisez les commandes port-forward pour acc√©der aux interfaces."
    echo ""
}

# Gestion des arguments
case "${1:-}" in
    "destroy")
        destroy_deployment
        ;;
    "status")
        check_status
        ;;
    "help")
        show_help
        ;;
    "")
        main
        ;;
    *)
        log_error "Argument invalide: $1"
        echo ""
        show_help
        exit 1
        ;;
esac